---
layout: post
comments: true
categories: 算法
---

* content
{:toc}

本博客的全部算法文章为原创，如需转换请备注转发链接谢谢~~~

备注：代码是自己手撕的，没有实践，如果有错，自己纠正，因为思想就是那样的了，我就节省时间不一一实践了。

### 时间复杂度和空间复杂度

下图就是本篇文章说到的排序算法，之后可能会补充其它的排序算法吧~
<br>

![avatar](/static/img/sort.jpg){:width="90%"}

---

### 冒泡排序（蛮力法）

冒泡排序（bubble sort）过程如下（升序）：

![1](/static/img/sorts/1.gif){:width="50%"}

这里就以简单的以升序为例，因为冒泡排序的思想都是一样的，所以我就不做过多的阐述。

思想：对无序区从前向后依次比较相邻记录，若反序则交换，从而使得值较小的记录向前移，值较大的记录向后移（都说冒泡了，就跟在水中的气泡一样，体积大的先浮上来）

代码如下：

{%highlight ruby%}
void bubble_sort(int arr[], int len)
{
    int i, j , temp;
    for (i = 0; i < len - 1; i++)
    {
        for (j = 0; j < len - 1 - i; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
{%endhighlight%}

---

### 选择排序（蛮力法）

选择排序（selection_sort）过程如下（升序）:

![2](/static/img/sorts/2.gif){:width="50%"}

思想：在无序区找出最小的记录，然后将它与无序区的第一个记录交换，使得有序去扩展一个记录，同时无序区减少一个记录。

代码如下：

{%highlight ruby%}
void selection_sort(int arr[], int len)
{
    int i,j,index,temp;
    for(i=0;i < len;i++)
    {
        index=i;
        for(j=i+1;j < len;j++)
        {
            if(arr[j] < arr[index])index=j;
        }
        if(index != i)
        {
            temp=arr[i];
            arr[i]=arr[index];
            arr[index]=temp;
        }
    }
}
{%endhighlight%}

---

### 插入排序（减治法）

插入排序（InsertSort）过程如下（升序）：

![3](/static/img/sorts/3.gif){:width="50%"}

思想：