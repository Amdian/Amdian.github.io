~~~c++
#include <bits/stdc++.h>
using namespace std;

const int NUM=5005;
const int maxn_m=2e5+5;
int S[NUM];//并查集
struct Edge{//定义边
    int u,v,w;
}edge[maxn_m];

bool cmp(Edge a,Edge b){return a.w<b.w;}

//int find(int u){return S[u]==u?u:find(S[u]);}//查询并查集，返回u的根节点

int find(int x)//非递归方式压缩路径
{
    int k, j, r;
    r = x;
    while(r != S[r])     //查找跟节点
        r = S[r];      //找到跟节点，用r记录下
    k = x;
    while(k != r)             //非递归路径压缩操作
    {
        j = S[k];         //用j暂存S[k]的父节点
        S[k] = r;        //S[x]指向跟节点
        k = j;                    //k移到父节点
    }
    return r;         //返回根节点的值
}

int n,m;

int kruskal()
{
    int ans=0;
    for(int i=1;i<=n;i++)S[i]=i;//初始化，开始时每个村庄都是单独的集
    sort(edge+1,edge+1+m,cmp);
    for(int i=1;i<=m;i++)
    {
        int b=find(edge[i].u);//边的前端点u属于哪个集
        int c=find(edge[i].v);//边的后端点v属于哪个集
        if(b==c)continue;//产生圈，丢弃这个边
        S[c]=b;//合并
        ans+=edge[i].w;//计算MST
    }
    return ans;
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>edge[i].u>>edge[i].v>>edge[i].w;
    }
    cout<<kruskal()<<endl;
    return 0;
}
