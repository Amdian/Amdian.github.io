I"<ul id="markdown-toc">
  <li><a href="#数据的表示" id="markdown-toc-数据的表示">数据的表示</a>    <ul>
      <li><a href="#进制的转换" id="markdown-toc-进制的转换">进制的转换</a></li>
      <li><a href="#数的表示" id="markdown-toc-数的表示">数的表示</a></li>
      <li><a href="#浮点数的运算" id="markdown-toc-浮点数的运算">浮点数的运算</a></li>
      <li><a href="#算术运算和逻辑运算" id="markdown-toc-算术运算和逻辑运算">算术运算和逻辑运算</a></li>
    </ul>
  </li>
  <li><a href="#效验码" id="markdown-toc-效验码">效验码</a>    <ul>
      <li><a href="#奇偶效验码" id="markdown-toc-奇偶效验码">奇偶效验码</a></li>
      <li><a href="#循环冗余效验码-crc" id="markdown-toc-循环冗余效验码-crc">循环冗余效验码 CRC</a></li>
      <li><a href="#海明效验码" id="markdown-toc-海明效验码">海明效验码</a></li>
    </ul>
  </li>
  <li><a href="#计算机硬件和指令" id="markdown-toc-计算机硬件和指令">计算机硬件和指令</a>    <ul>
      <li><a href="#计算机的硬件基本系统" id="markdown-toc-计算机的硬件基本系统">计算机的硬件基本系统</a></li>
      <li><a href="#计算机指令的组成" id="markdown-toc-计算机指令的组成">计算机指令的组成</a></li>
      <li><a href="#计算机指令执行过程" id="markdown-toc-计算机指令执行过程">计算机指令执行过程</a></li>
      <li><a href="#指令寻址方式" id="markdown-toc-指令寻址方式">指令寻址方式</a></li>
      <li><a href="#指令操作数的寻址方式" id="markdown-toc-指令操作数的寻址方式">指令操作数的寻址方式</a></li>
    </ul>
  </li>
  <li><a href="#计算机体系结构分类" id="markdown-toc-计算机体系结构分类">计算机体系结构分类</a></li>
  <li><a href="#指令系统-cisc-和-rcsc" id="markdown-toc-指令系统-cisc-和-rcsc">指令系统 CISC 和 RCSC</a></li>
  <li><a href="#指令的流水处理" id="markdown-toc-指令的流水处理">指令的流水处理</a>    <ul>
      <li><a href="#流水线原理" id="markdown-toc-流水线原理">流水线原理</a></li>
      <li><a href="#流水线时间计算" id="markdown-toc-流水线时间计算">流水线时间计算</a></li>
      <li><a href="#流水线吞吐率计算" id="markdown-toc-流水线吞吐率计算">流水线吞吐率计算</a></li>
      <li><a href="#流水线的加速比计算" id="markdown-toc-流水线的加速比计算">流水线的加速比计算</a></li>
      <li><a href="#流水线效率" id="markdown-toc-流水线效率">流水线效率</a></li>
    </ul>
  </li>
  <li><a href="#存储系统" id="markdown-toc-存储系统">存储系统</a>    <ul>
      <li><a href="#计算机存储结构层次图" id="markdown-toc-计算机存储结构层次图">计算机存储结构层次图</a></li>
      <li><a href="#局部性原理" id="markdown-toc-局部性原理">局部性原理</a></li>
      <li><a href="#高速缓存cache" id="markdown-toc-高速缓存cache">高速缓存Cache</a></li>
      <li><a href="#虚拟存储器" id="markdown-toc-虚拟存储器">虚拟存储器</a></li>
    </ul>
  </li>
  <li><a href="#输入输出技术" id="markdown-toc-输入输出技术">输入输出技术</a></li>
  <li><a href="#总线" id="markdown-toc-总线">总线</a></li>
  <li><a href="#系统可靠性分析" id="markdown-toc-系统可靠性分析">系统可靠性分析</a></li>
  <li><a href="#计算机安全概述" id="markdown-toc-计算机安全概述">计算机安全概述</a>    <ul>
      <li><a href="#信息安全的基本要素" id="markdown-toc-信息安全的基本要素">信息安全的基本要素</a></li>
      <li><a href="#计算机的安全等级" id="markdown-toc-计算机的安全等级">计算机的安全等级</a></li>
      <li><a href="#安全需求与威胁" id="markdown-toc-安全需求与威胁">安全需求与威胁</a></li>
    </ul>
  </li>
  <li><a href="#加密技术和认证技术" id="markdown-toc-加密技术和认证技术">加密技术和认证技术</a>    <ul>
      <li><a href="#对称和不对称的加密技术保密性" id="markdown-toc-对称和不对称的加密技术保密性">对称和不对称的加密技术——保密性</a></li>
    </ul>
  </li>
</ul>

<h3 id="数据的表示">数据的表示</h3>
<p><br /></p>

<h4 id="进制的转换">进制的转换</h4>

<blockquote>
  <p><strong>☄ R进制转换十进制</strong></p>

  <p>例如：有6进制数5043，那么转换成十进制 = 3 * 6^0+4 * 6^1+0 * 6^2+5 * 6^3=1107;</p>

  <p><strong>☄ 十进制转R进制</strong></p>

  <p>❶当十进制是整数时
例如：有十进制数100，转换成16进制，用100除以R，记录每次的余数，若商不为0，则继续除以R，直至商为0，最后结果 64</p>

  <p>❷当十进制是小数时
例如：有十进制数2.25，转换成2进制，用R乘以十进制小数的每一位，记录每次所得整数，若结果小数部分不为0，则继续乘，直至没有小数，结果为10.01</p>

  <p><strong>☄ m进制转n进制</strong></p>

  <p>方法：先将m进制转换成十进制，再将十进制转换成n进制</p>

  <p><strong>☄ 二进制转八进制</strong></p>

  <p>方法：每三位二进制数转为一位8进制数，二进制数位个数不是三的倍数，则在前面补0，例如：二进制01101有五位，则在前面补0，变成001 101，每三位转为一位八进制数，001=1,101=1+4=5，也即01101=15；</p>

  <p><strong>☄ 二进制转十六进制</strong></p>

  <p>方法：每四位二进制转为一位十六进制，方法跟上面差不多，例如：101101，先补0，变成0010 1101.每四位转为一位十六进制，0010=2 1101=D，也即101101=2D。</p>
</blockquote>

<hr />

<h4 id="数的表示">数的表示</h4>

<p>各种数值在计算机中表示的形式称为<strong>机器数</strong>。其特定就是使用二进制计数制，符号用0和1表示，小数点则隐含，不占位置。</p>

<p>机器数有无符号数和带符号数之分。无符号数表示正数，没符号位。带符号数最高位为符号位，正数符号位为0，负数符号位为1。定点表示法分 纯小数和纯整数两种，其中小数点不占存储位，而是按照以下约定：</p>

<blockquote>
  <p><strong>纯小数</strong>:约定小数点的位置在机器数的最高数值位之前。</p>

  <p><strong>纯整数</strong>：约定小数点的位置在机器数的最低数值位之后。</p>

  <p><strong>真值</strong>：机器数对应的实际数值。</p>
</blockquote>

<p>带符号数有下列编码方式：</p>

<blockquote>
  <p><strong>原码</strong>：一个数的正常二进制表示，最高位表示符号，其中数值0的源码有两种形式，例如：+0（0 0000000）和-0（1 0000000）。</p>

  <p><strong>反码</strong>：正数的反码即原码；负数的反码是在原码的基础上，除符号位外，其他各位按位取反。数值0的反码也有两种形式：+0（0 0000000）和-0（1 1111111）。</p>

  <p><strong>补码</strong>：正数的补码即原码；负数的补码是在原码的基础上，除符号位外，其他各位按位取反，而后末位+1，，<font size="3" color="#8B0000">若有进制为则产生进位</font>。因此数值0 的补码只有一种形式+0 = -0 =0 0000000.</p>

  <p><strong>移码</strong>：用作浮点运算的阶码，<font size="3" color="#8B0000">无论正数负数</font>，都是将该原码的<font size="3" color="#8B0000">补码的首位（符号位）取反</font>得到移码。</p>

  <p><strong>符号表示</strong>：注意-&gt;原码最高位是代表正负号，且不参与计数；而其他编码最高位虽然也是代表正负号，但参与计数。</p>
</blockquote>

<p>机器字长为n时，各种码制表示的带符号数的取值范围：</p>

<table>
    <tr>
        <td>码制</td>
        <td>定 点 整 数</td>
        <td>定 点 小 数</td>
    </tr>
        <tr>
        <td>原码</td>
        <td>-(2^n-1 - 1)~ + (2^n-1 - 1)</td>
        <td>-(1 - 2^-(n-1))~ + (1 - 2^-(n-1))</td>
    </tr>
        <tr>
        <td>反码</td>
        <td>-(2^n-1 - 1)~ + (2^n-1 - 1)</td>
        <td>-(1 - 2^-(n-1))~ + (1 - 2^-(n-1))</td>
    </tr>
        <tr>
        <td>补码</td>
        <td>-2^n-1 ~ + (2^n-1 - 1)</td>
        <td>-1~ + (1-2^-(n-1))</td>
    </tr>
        <tr>
        <td>移码</td>
        <td>-2^n-1 ~ + (2^n-1 - 1)</td>
        <td>-1~ + (1-2^-(n-1))</td>
    </tr>
</table>
<p>差别在于0 的表示，原码和反码分+0和-0，补码只有一个0，因此可以多表示一个。</p>

<hr />

<h4 id="浮点数的运算">浮点数的运算</h4>

<p><strong>浮点数</strong>：表示方法为 N=F*2^E，其中E称为阶码，F为尾数；类似于十进制的科学计数法，如82.125=0.85125 * 10^2，二进制如101.011 = 0.101011 * 2^3。</p>

<p>在浮点数的表示中，阶码为带符号的纯整数，尾数为带符号的纯小数，要注意符号占最高位（正数0 负数1），其表示格式如下：</p>

<table>
    <tr>
        <td>阶符</td>
        <td>阶码</td>
        <td>数符</td>
        <td>尾数</td>
    </tr>
</table>

<p>一个浮点数的表示方法不是唯一的，浮点数所能表示的数值范围由阶码确定，所表示的数值精度由尾数确定。</p>

<p>尾数:表示方法则采用规格化方法，也即带符号尾数的补码必须为1.0xxxx（负数）或者0.1xxxx（负数），其中x可为0或1.</p>

<p><strong>浮点数的运算</strong>：对阶（使两个数的阶码相同，小阶向大阶看齐，较小阶码增加几位，尾数右移几位）- 尾数计算（相加，若是减运算，则加负数）- 结果规格化（即尾数表示规格化，带符号尾数转换为1.0xxxx或者0.1xxxx）。</p>

<hr />

<h4 id="算术运算和逻辑运算">算术运算和逻辑运算</h4>

<p>算术运算包括 + - * / 等基本运算。</p>

<p>逻辑运算如下：</p>

<blockquote>
  <p>☞ 逻辑与&amp;&amp;：0和1相与，只要有一个为0结果就为0，两个都为1才为1.</p>

  <p>☞ 逻辑或||：0和1相或，只要有一个为1结果就为1，两个0才为0.</p>

  <p>☞ 异或：同0非1，即参加运算的二进制数同为0或者同为1结果为0，一个为0另一个为1结果为1.</p>

  <p>☞ 逻辑非!：0的非是1,1的非是0.</p>

  <p>☞ 逻辑左移«：二进制数整体左移n位，高位若溢出则舍去，地位补0.</p>

  <p>☞ 逻辑右移»：二进制数整体右移n位，地位溢出则舍去，高位补0.</p>

  <p>☞ 算术左移算术右移：乘以2或者除以2的算术运算，涉及加减乘除的都是算术运算，与逻辑运算曲风。</p>

  <p>☞ 短路计算方式：指通过逻辑运算符（&amp;&amp;、||）左边表达式就能推算出整个表达式的值，不再继续执行执行逻辑运算符右边的表达式。</p>
</blockquote>

<p>从计算的角度理解，正数和负数相加其结果肯定不会溢出，如果有溢出，必然同为正数或者同为负数，结果才会更大，有可能溢出。</p>

<hr />

<h3 id="效验码">效验码</h3>

<p><br /></p>

<p>码距：就单个编码A：00而言，其码距为1，因为其只需要改变一位就变成另一个编码。在两个编码中，从A码到B码转换所需要改变的位数称为码距，如A：00要转换为B：00，码距为2。一般来说，码距越大，越有利于纠错和检错。</p>

<hr />

<h4 id="奇偶效验码">奇偶效验码</h4>

<p>在编码中增加1位效验码来使编码中1的个数为奇数（奇校验）或者偶数（偶校验），从而使码距变为2。奇校验可以检验编码中奇数位出错，即当前合法编码中的奇数位发生了错误时，即编码中的1变成0或者0变成1，则该编码中1的个数的奇偶性就发生了变化，从而检查出错误。但无法纠错。</p>

<p><img src="/static/img/software_designer/2.jpg" alt="奇偶效验码" width="50%" /></p>

<p>例如：原始码为101100 奇效验则为101100 0 偶效验则为1011000 1，
假如我发送给对方是101100，其奇效验位为 “0”，假如接收方接收的时候，也是收到101100，那么接收方计算出的奇效验位也是“0”，因为与我发送的是一样的，表示此次传输的数据没有错误。</p>

<p>从上面可以看出，其实奇偶效验码也会存在弊端，是因为假如有两位的出错了，那么这个奇偶效验码是无法检测的。</p>

<hr />

<h4 id="循环冗余效验码-crc">循环冗余效验码 CRC</h4>

<p>CRC只能检错，不能纠错，下面将通过题来认识CRC；</p>

<p>题目：原始报文为“ 11001010101 ”，其中多项式为：“ x^4+x^3+x+1 ”。对其进行CRC编码后的结果为？</p>

<p>解题过程：</p>

<p>①获取除数，根据多项式得出除数为 11011；</p>

<p>②根据多项式的最高次数为4，则需在原始多项式后补4个0，则变成11001010101 0000
然后就可以除了，位与位之间是异或运算，最后得出四位的余数，就是CRC效验码，在原始的后面加上这四位CRC效验码，然后发送出去。</p>

<p><img src="/static/img/software_designer/1.jpg" alt="CRC" width="50%" /></p>

<p>然后假如余数只有两位，则在前面补0，补到四位。结果变成0011</p>

<p>然后对方会将接收到的11001010101 0011 与11011进行模2运算（就是跟上面求CRC效验码一样），假如余数为0，则说效验码正确，数据传输正确。</p>

<hr />

<h4 id="海明效验码">海明效验码</h4>

<p>直接讲例子吧，如下：
备注：2^r &gt; m + r + 1，r是效验码的位数，m是数据位
假如r=3,则效验位为1,2,4</p>

<p>题目：求信息1011的海明码。
（1）2^r &gt; m + r + 1，确认效验码为3位：2^3 &gt; 4 + 3 + 1。分别放在2^0，2^1，2^2位。</p>

<p>（2）列出效验位公式。</p>

<p>3 = 2^1+2^0 = r1+r0</p>

<p>5 = 2^2+2^0 = r2+r0</p>

<p>6 = 2^2+2^1 = r2+r1</p>

<p>7 = 2^2+2^1+2^0 = r2+r1+r0</p>

<p>然后可以列出一个原始表如下：</p>

<table>
  <tbody>
    <tr>
      <td>位数</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>信息位</td>
      <td>i4</td>
      <td>i3</td>
      <td>i2</td>
      <td> </td>
      <td>i1</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>效验位</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>r2</td>
      <td> </td>
      <td>r1</td>
      <td>r0</td>
    </tr>
  </tbody>
</table>

<p>（3）根据公式得r2=0，r1=0，r0=1，过程如下：</p>

<p>r2=i2⊕i3⊕i4</p>

<p>r1=i4⊕i3⊕i1</p>

<p>r0=i4⊕i2⊕i1</p>

<p>（4）将数据加入表格，如下所示</p>

<table>
  <tbody>
    <tr>
      <td>位数</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>信息位</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>效验位</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>0</td>
      <td> </td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>然后进行异或运算</p>

<p>r2⊕i2⊕i3⊕i4=1⊕1⊕0⊕1=1</p>

<p>r1⊕i4⊕i3⊕i1=0⊕1⊕0⊕0=0</p>

<p>r0⊕i4⊕i2⊕i1=1⊕1⊕1⊕1=0</p>

<p>结果：1011的海明码为1011101</p>

<hr />

<h3 id="计算机硬件和指令">计算机硬件和指令</h3>

<p><br /></p>

<h4 id="计算机的硬件基本系统">计算机的硬件基本系统</h4>

<p>不多说，采用百科的图，如下：</p>

<p><img src="/static/img/software_designer/3.jpg" alt="计算机系统" width="70%" /></p>

<p>下面将浅谈常考的选择题知识点：</p>

<p><strong>CPU</strong>：由 运算器、控制器、寄存器和内部总线组成。实现程序控制、操作控制、时间控制、数据处理功能。</p>

<p><strong>运算器</strong>：由<strong>算术逻辑单元ALU</strong>（实现对数据的算术和逻辑运算）、<strong>累加寄存器AC</strong>（运算结果或源操作数的存放区）、<strong>数据缓冲寄存器DR</strong>（暂时存放内存的指令或数据）、和<strong>状态条件寄存器PSW</strong>（保存指令运行结果的条件码内容，如溢出标志等）组成。执行所有的算术运算，如加减乘除等；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较等。</p>

<p><strong>控制器</strong>：由<strong>指令寄存器IR</strong>（暂存CPU执行指令）、<strong>程序计数器PC</strong>（存放指令执行地址）、<strong>地址寄存器AR</strong>（保存当前CPU所访问的内存地址）、<strong>指令译码器ID</strong>（分析指令操作码）等组成。控制整个CPU的工作，最为重要。</p>

<h4 id="计算机指令的组成">计算机指令的组成</h4>

<p>一条指令由 <strong>操作码</strong> 和 <strong>操作数</strong> 两部分组成，操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。</p>

<p>在计算机中，操作要求和操作地址都由二进制数码表示，分别称作操作码和地址码，整条指令以二进制编码的形式存放在存储器中。</p>

<hr />

<h4 id="计算机指令执行过程">计算机指令执行过程</h4>

<p>可分为取指令 —— 分析指令 —— 执行指令 三个步骤。过程如下</p>

<p>①首先将程序计数器PC中的指令地址取出，送入地址总线，CPU依据指令地址去内存中取出指令内容存入指令寄存器IR；</p>

<p>②而后由指令译码器进行分析，分析指令操作码；</p>

<p>③最后执行指令，取出指令执行所需的源操作数。</p>

<hr />

<h4 id="指令寻址方式">指令寻址方式</h4>

<p><strong>顺序寻址方式</strong>：由于指令地址在主存中顺序排列，当执行一段程序时，通常是一条指令接着一条指令这样子的一个顺序执行。过程如下:</p>

<p>①从存储器取出第一条指令，然后执行这条指令</p>

<p>②接着从存储器取出第二条指令，再执行第二条指令</p>

<p>③….以此类推。</p>

<p>上述的过程称为指令的顺序寻址方式。</p>

<p><strong>跳跃寻址方式</strong>:所谓指令的跳跃寻址,是指下一条指令的地址码不是由程序计数器给出,而是由本条指令直接给出。程序跳跃后,按新的指令地址开始顺序执行。因此,指令计数器的内容也必须相应改变,以便及时跟踪新的指令地址。</p>

<hr />

<h4 id="指令操作数的寻址方式">指令操作数的寻址方式</h4>

<p><strong>立即寻址方式</strong>:指令的地址码字段指出的不是地址,而是操作数本身。</p>

<p><strong>直接寻址方式</strong>:在指令的地址字段中直接指出操作数在主存中的地址。</p>

<p><strong>间接寻址方式</strong>:与直接寻址方式相比,间接寻址中指令地址码字段所指向的存储单元中存储的不是操作数本身,而是操作数的地址。</p>

<p><strong>寄存器寻址方式</strong>:指令中的地址码是寄存器的编号,而不是操作数地址或操作数本身。</p>

<p>寄存器的寻址方式也可以分为直接寻址和间接寻址两者的区别在于:</p>

<p>❶前者的指令地址码给出寄存器编号,寄存器的内容就是操作数本身;</p>

<p>❷后者的指令地址码给出寄存器编号,寄存器的内容是操作数的地址,根据该地址访问主存后才能得到真正的操作数。</p>

<p><strong>基址寻址方式</strong>:将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址,其优点是可以扩大寻址能力。</p>

<p><strong>变址寻址方式</strong>:变址寻址方式计算有效地址的方法与基址寻址方式很相似,它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。</p>

<p><strong>相对寻址方式</strong>:相对于当前的指令地址而言的寻址方式。相对寻址是把程序计数器PC的内容加上指令中的形式地址而形成操作数的有效地址,而程序计数器的内容就是当前指令的地址,所以相对寻址是相
对于当前的指令地址而言的。</p>

<hr />

<h3 id="计算机体系结构分类">计算机体系结构分类</h3>

<p>按处理机的数量进行分类:单处理系统(一个处理单元和其他设备集成)、并行处理系统(两个以上的处理机互联)、分布式处理系统(物理上远距离且松耦合的多计算机系统)。</p>

<p>Flynn分类法</p>

<p><img src="/static/img/software_designer/4.jpg" alt="Flynn分类法" width="80%" /></p>

<p>由上图可知，分类由两个因素，即指令流和数据流，指令流由控制部分处理，每一个控制部分处理一条指令流；数据流由处理器处理，每一个处理器处理一条数据流。</p>

<hr />

<h3 id="指令系统-cisc-和-rcsc">指令系统 CISC 和 RCSC</h3>

<p>CISC是复杂指令系统,兼容性强,指令繁多、长度可变,由微程序实现；</p>

<p>RCSC是精简指令系统,指令少,使用频率接近,主要依靠硬件实现(通用寄存器、硬布线逻辑控制）。</p>

<p><img src="/static/img/software_designer/5.jpg" alt="指令系统 CISC 和 RCSC" width="80%" /></p>

<hr />

<h3 id="指令的流水处理">指令的流水处理</h3>

<p><br /></p>

<h4 id="流水线原理">流水线原理</h4>

<p>将指令分成不同段,每段由不同的部分去处理,因此可以产生叠加的效果,所有的部件去处理指令的不同段,如下图所示:</p>

<p><img src="/static/img/software_designer/6.jpg" alt="6" width="80%" /></p>

<p>RISC中的流水线技术:超流水线(在每个机器周期内能完成一个甚至两个浮点操作,以时间换空间)、超标量(内装多条流水线同时执行多个处理,以空间换时间)、超长指令字VLW(同时执行多条指令,发挥软件作用)。</p>

<p>-【–</p>

<h4 id="流水线时间计算">流水线时间计算</h4>

<p><strong>流水线周期</strong>:指令分成不同执行段,其中执行时间最长的段为流水线周期。</p>

<p><strong>流水线执行时间</strong>:1条指令总执行时间+(总指令条数1)*流水线周期。</p>

<p><strong>单缓冲区</strong>和<strong>双缓冲区</strong>:此类题型不给出具体流水线执行阶段,需要考生自己区分出流水线阶段,一般来说,能够同时执行的阶段就是流水线的独立执行阶段:只能独立执行的阶段应该合并为流水线中的一个独立执行阶段。</p>

<p>例如有三个阶段即读入缓冲区+送入用户区+数据处理,在单缓冲区中,缓冲区和用户区都只有一个,一个盘块必须执行完前两个阶段,下一个盘块才能开始,因此前两个阶段应该合并,整个流水线为送入用户区数据处理;</p>

<p>而在双缓冲区中,盘块可以交替读入缓冲区但用户区只有一个,因为缓冲区阶段可以同时进行,流水线前两个阶段不能合并,就是读入缓冲区送入用户区数据处理三段。</p>

<p>划分出真正的流水线阶段后,套用流水线时间计算公式可以轻易得出答案。</p>

<hr />

<h4 id="流水线吞吐率计算">流水线吞吐率计算</h4>

<p>吞吐率即单位时间内执行的指令条数。公式如下：</p>

<p><img src="/static/img/software_designer/7.jpg" alt="7" width="50%" /></p>

<p>最大吞吐率（了解即可）:</p>

<p><img src="/static/img/software_designer/8.jpg" alt="8" width="50%" /></p>

<hr />

<h4 id="流水线的加速比计算">流水线的加速比计算</h4>

<p>加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高，公式如下：</p>

<p><img src="/static/img/software_designer/9.jpg" alt="9" width="40%" /></p>

<hr />

<h4 id="流水线效率">流水线效率</h4>

<p>E=n个任务占用的时空区/k个流水段的总的时空区</p>

<p>例：码字….得制作出合适得图在回来解释。</p>

<hr />

<h3 id="存储系统">存储系统</h3>

<p><br /></p>

<h4 id="计算机存储结构层次图">计算机存储结构层次图</h4>

<p><img src="/static/img/software_designer/10.jpg" alt="10" width="60%" /></p>

<font size="3" color="#8B0000">计算机采用分级存储体系的主要目的是为了解决存储容量、成本和速度直接的矛盾问题</font>

<p><strong>两级存储映像为</strong>：Cache-主存、主存-辅存（虚拟存储体系）。</p>

<p><strong>存储器的分类</strong>：</p>

<blockquote>
  <p>☞ 按存储器所处的位置：内存、外存</p>

  <p>☞ 按存储介质分类：半导体存储器、磁表面存储器（磁带）、光存储器。</p>

  <p>☞ 按存取器的工作方式：只读存储器(ROM)、随机读写存储器(RAM)。</p>

  <p>☞ 按存储器的访问方式：按地址访问、按内容访问（相联存储器）。</p>

  <p>☞ 按寻址方式：随机存储器、顺序存储器、直接存储器(二者结合)。</p>
</blockquote>

<h4 id="局部性原理">局部性原理</h4>

<p>在CPU运行时，所访问的数据会趋向于一个较小的局部空间地址。</p>

<p>时间局部性原理：如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即在相邻的时间里会访问同一个数据项。</p>

<p>空间局部性原理：在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近，即相邻的空间地址会连续访问。</p>

<hr />

<h4 id="高速缓存cache">高速缓存Cache</h4>

<p><strong>高速缓存Cache</strong> 用来存储当前最活跃的程序和数据,直接与CPU交互,位于cPU和主存之间,容量小,速度为内存的5-10倍,由半导体材料构成。其内容是主存内存的副本拷贝,对于程序员来说是透明的。</p>

<p>Cache 由控制部分和存储器组成存储器存储数据,控制部分判断CPU要访问的数据是否在Cache 中,在则命中,不在则依据一定的算法从主存中替换。</p>

<p><strong>地址映射方法</strong></p>

<p>在CPU工作时,送出的是主存单元的地址,而应从Cache.存储器中读/写信息。这就需要将主存地址转换为Cache 存储器地址,这种地址的转换称为地址映像,由硬件自动完成映射,分为下列三种方法：</p>

<blockquote>
  <p><strong>直接映像</strong>:将Cache 存储器等分成块,主存也等分成块并编号。主存中的块与Cache 中的块的对应关系是固定的,也即二者块号相同才能命中。地址变换简单但不灵活,容易造成资源浪费。</p>

  <p><strong>全相联映像</strong>:同样都等分成块并编号。主存中任意一块都与Cache 中任意一块对应。因此可以随意调入Cache 任意位置,但地址变换复杂,速度较慢。因为主存可以随意调入Cache 任意块,只有当Cache满了才会发生块冲突,是最不容易发生块冲突的映像方式。</p>

  <p><strong>组组相连映像</strong>:前面两种方式的结合,将Cache 存储器先分块再分组主存也同样先分块再分组,组间采用直接映像,即主存中组号与Cache中组号相同的组才能命中,但是组内全相联映像,也即组号相同的两个组内的所有块可以任意调换。</p>
</blockquote>

<p><strong>命中率及平均时间</strong></p>

<p>Cache 存储器的大小一般为K或者M单位,很小,但是最快,仅次于CPU中的寄存器,而寄存
器一般不算作存储器,CPU与内存之间的数据交互,内存会先将数据拷贝到Cahe里,这样,根据局部性原理,若Cache 中的数据被循环执行,则不用每次都去内存中读取数据,会加快CPU工作效率。</p>

<p>因此,Cache 有一个命中率的概念,即当CPU所访问的数据在Cache 中时,命中,直接从  cache中读取数据设读取一次Cache时间为1ns,若CPU访问的数据不在Cache 中,则需要从内存中读取,设读取一次内存的时间为1000ns,若在CPU多次读取数据过程中,有90%命中Cache,,则cPU读取一次的平均时间为 (90%<em>1+10%</em>1000)ns 。</p>

<hr />

<h4 id="虚拟存储器">虚拟存储器</h4>

<p>虚拟存储器技术是将很大的数据分成许多较小的块,全部存储在外存中。运行时,将用到的数据调入主存中,马上要用到的数据置于缓存中,这样,一边运行一边进行所需数据块的调入调出。对于应用程序员来说,就好像有一个比实际主存空间大得多的虚拟主存空间,基本层级为:主存——缓存—外存。与CPU—高速缓存Cache-—-主存的原理类似。但虚拟存储器中程序员无需考虑地址映像关系,由系统自动完成,因此对于程序来说是透明的。
其管理方式分为页式、段式、段页式。</p>

<hr />

<h3 id="输入输出技术">输入输出技术</h3>

<p><strong>程序控制(查询)方式</strong>：CPU主动查询外设是否完成数据传输,效率极低。</p>

<p><strong>程序中断方式</strong>：外设完成数据传输后,向CPU发送中断,等待CPU处理数据,效率相对较高。中断响应时间指的是从发出中断请求到开始进入中断处理程序:中断处理时间指的是从中断处理开始到中断处理结束。中断向量提供中断服务程序的入口地址。多级中断嵌套,使用堆栈来保护断点和现场。</p>

<p><strong>DMA方式(直接主存存取)</strong>:CPU只需完成必要的初始化等操作,数据传输的整个过程都由DMA控制器来完成,在主存和外设之间建立直接的数据通路,效率很高。在一个总线周期结束后,CPU会响应DMA请求开始读取数据:CPU响应程序中断方式请求是在一条指令执行结束时:区分指令执行结束和总线周期结束。</p>

<p>通道:也是一种处理机,内部具有独立的处理系统,使数据的传输独立于CPU。分为字节多路通道的传送方式(每一次传送一个通道的一个字节,多路通道循环)和选择通道的传送方式(选择一个通道,先传送完这个通道的所有字节,再开始下一个通道传送)。</p>

<hr />

<h3 id="总线">总线</h3>

<p>从广义上讲,任何连接两个以上电子元器件的导线都可以称为总线,通常分为以下三类:</p>

<p><strong>内部总线</strong>:内部芯片级别的总线,芯片与处理器之间通信的总线。</p>

<p><strong>系统总线</strong>:是板级总线,用于计算机内各部分之间的连接,具体分为数据总线(并行数据传输位数)、地址总线(系统可管理的内存空间的大小)、控制总线(传送控制命令)。代表的有ISA总线、EISA总线、PCI总线。</p>

<p><strong>外部总线</strong>：设备一级的总线，微机和外部设备的总线。代表的有RS232（串行总线）、SCSI(并行总线)、USB(通用串行总线，即插即用，支持热拔插)。</p>

<p>并行总线适合近距离高速数据传输，串行总线适合长距离数据传输，专用总线在设计上可以与连接设备实现最佳匹配。</p>

<p>总线计算：总线的时钟周期=时钟频率的倒数；总线的宽度（传输速率）=单位时间内传输的数据总量/单位时间大小。</p>

<hr />

<h3 id="系统可靠性分析">系统可靠性分析</h3>

<p>串联系统：一个设备不可靠，整个系统奔溃：
R=R1 * R2 * R3 * … * Rn</p>

<p>并联系统，所有设备都不可靠，整个系统才奔溃：
R=1-(1-R1) * (1-R2) * … * (1-Rn)</p>

<p>通过例子来讲吧</p>

<p><img src="/static/img/software_designer/11.jpg" alt="11" width="70%" /></p>

<p><img src="/static/img/software_designer/12.jpg" alt="12" width="70%" /></p>

<p><img src="/static/img/software_designer/13.jpg" alt="13" width="70%" /></p>

<hr />

<h3 id="计算机安全概述">计算机安全概述</h3>

<p><br /></p>

<h4 id="信息安全的基本要素">信息安全的基本要素</h4>

<p>保密性:确保信息不暴露给未授权的实体,包括最小授权原则(只赋给使用者恰好够用的权限,防止其看到其他保密的数据)、防暴露(将物理数据库文件名和扩展名都修改为一串乱码,防止他人轻易找到复制)、信息加密、物理保密。</p>

<p>完整性:保证数据传输过程中是正确无误的,接收和发送的数据相同,包括安全协议、校验码、密码校验、数字签名、公证等手段。</p>

<p>可用性:保证合法的用户能以合法的手段来访问数据,包括综合保障(IP过滤、业务流控制、路由选择控制、审计跟踪)。</p>

<p>可控性:控制授权范围内的信息流向及行为方式。</p>

<p>可审查性:对出现的安全问题提供调查的依据和手段。</p>

<hr />

<h4 id="计算机的安全等级">计算机的安全等级</h4>

<p><img src="/static/img/software_designer/14.jpg" alt="14" width="80%" /></p>

<hr />

<h4 id="安全需求与威胁">安全需求与威胁</h4>

<p><strong>安全需求</strong>可划分为物理线路安全、网络安全、系统安全和应用安全；从各级安全需求字面上也可以理解，物理线路就是物理设备、物理环境；网络安全指网络上的攻击、入侵；系统安全指的是操作系统漏洞、补丁等；应用安全就是上层的应用软件，包括数据库软件。</p>

<p><strong>安全威胁分类</strong>这里就不去阐述了~</p>

<hr />

<h3 id="加密技术和认证技术">加密技术和认证技术</h3>

<p><br /></p>

<h4 id="对称和不对称的加密技术保密性">对称和不对称的加密技术——保密性</h4>

<p><strong>对称加技术</strong>，就是对数据的加密和解密的密钥（密码）是相同的，属于不公开密匙加密算法。其缺点是加密强度不高（因为只有一个密钥），且密钥分发困难（因为密钥还需要传输给接收方，也要考虑保密性等问题）。</p>

<p>对称密钥加密算法如下：DES、AES、RC-5、IDEA算法</p>

<p><strong>非对称加密技术</strong>，就是对数据的加密和解密的密钥是不同的，是公开密钥加密算法。其缺点就是速度慢（密钥有1024位，计算量大，不适合加密大数据）。</p>

<p><strong>非对称技术的原理如下</strong></p>

<blockquote>
  <p>① 发送方 甲方 和 接收方 乙方 都分别有各自的公钥和密钥，且甲方的公钥加密只能由甲方的私钥解密。</p>

  <p>②双方的公钥 是可以共享的，但是私钥只能自己保密，此时，<strong>甲方要传输数据给乙方，明显应该使用乙方的公钥来加密</strong>，这样只有使用乙方的私钥才能解密，而乙方的私钥只有乙方才有，保证了数据的保密性，也不用分发解密的密钥。</p>
</blockquote>

<p>常见的非对称加密算法如：RSA、Elgamal、ECC、背包算法、Rabin、D-H</p>

:ET