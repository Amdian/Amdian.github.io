I"<ul id="markdown-toc">
  <li><a href="#redis-事务的基本使用" id="markdown-toc-redis-事务的基本使用">Redis 事务的基本使用</a></li>
  <li><a href="#原子性" id="markdown-toc-原子性">原子性</a></li>
  <li><a href="#discard丢弃" id="markdown-toc-discard丢弃">discard（丢弃）</a></li>
  <li><a href="#优化" id="markdown-toc-优化">优化</a></li>
</ul>

<h4 id="redis-事务的基本使用">Redis 事务的基本使用</h4>

<p>每个事务的操作都有 begin、commit 和 rollback，begin 指示事务的开始，commit 指示事务的提交，rollback 指示事务的回滚。它大致的形式如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">begin</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
 <span class="n">command1</span><span class="o">();</span>
 <span class="n">command2</span><span class="o">();</span>
 <span class="o">....</span>
 <span class="n">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
 <span class="n">rollback</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Redis 在形式上看起来也差不多，分别是 multi/exec/discard。multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">multi</span>
<span class="no">OK</span>
<span class="o">&gt;</span> <span class="n">incr</span> <span class="n">books</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">incr</span> <span class="n">books</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">exec</span>
<span class="o">(</span><span class="n">integer</span><span class="o">)</span> <span class="mi">1</span>
</code></pre></div></div>

<p>上面的指令演示了一个完整的事务过程，所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为 Redis 的单线程特性，它不用担心自己在执行队列的时候被其它指令打搅，可以保证他们能得到的「原子性」执行。</p>
<p>上图显示了以上事务过程完整的交互效果。QUEUED 是一个简单字符串，同 OK 是一个形式，它表示指令已经被服务器缓存到队列里了。</p>

<hr />

<h4 id="原子性">原子性</h4>

<p>事务的原子性是指要么事务全部成功，要么全部失败，那么Redis 事务执行是原子性的么？</p>

<p>下面我们来看一个特别的例子。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">multi</span>
<span class="no">OK</span>
<span class="o">&gt;</span> <span class="n">set</span> <span class="n">books</span> <span class="n">iamastring</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">incr</span> <span class="n">books</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">set</span> <span class="n">poorman</span> <span class="n">iamdesperate</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">exec</span>
<span class="mi">1</span><span class="o">)</span> <span class="no">OK</span>
<span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">error</span><span class="o">)</span> <span class="no">ERR</span> <span class="n">value</span> <span class="n">is</span> <span class="n">not</span> <span class="n">an</span> <span class="n">integer</span> <span class="n">or</span> <span class="n">out</span> <span class="n">of</span> <span class="n">range</span>
<span class="mi">3</span><span class="o">)</span> <span class="no">OK</span>
<span class="o">&gt;</span> <span class="n">get</span> <span class="n">books</span>
<span class="s">"iamastring"</span>
<span class="o">&gt;</span> <span class="n">get</span> <span class="n">poorman</span>
<span class="err">"</span><span class="n">iamdesperate</span>
</code></pre></div></div>

<p>上面的例子是事务执行到中间遇到失败了，因为我们不能对一个字符串进行数学运算，事务在遇到指令执行失败后，后面的指令还继续执行，所以 poorman 的值能继续得到设置。</p>
<p>到这里，你应该明白 Redis 的事务根本不能算「原子性」，而仅仅是满足了事务的「隔离性」，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。</p>

<h4 id="discard丢弃">discard（丢弃）</h4>

<p>Redis 为事务提供了一个 discard 指令，用于丢弃事务缓存队列中的所有指令，在 exec 执行之前。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">get</span> <span class="nf">books</span>
<span class="o">(</span><span class="n">nil</span><span class="o">)</span>
<span class="o">&gt;</span> <span class="n">multi</span>
<span class="no">OK</span>
<span class="o">&gt;</span> <span class="n">incr</span> <span class="n">books</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">incr</span> <span class="n">books</span>
<span class="no">QUEUED</span>
<span class="o">&gt;</span> <span class="n">discard</span>
<span class="no">OK</span>
<span class="o">&gt;</span> <span class="n">get</span> <span class="nf">books</span>
<span class="o">(</span><span class="n">nil</span><span class="o">)</span>
</code></pre></div></div>

<p>我们可以看到 discard 之后，队列中的所有指令都没执行，就好像 multi 和 discard 中间的所有指令从未发生过一样</p>

<h4 id="优化">优化</h4>

:ET