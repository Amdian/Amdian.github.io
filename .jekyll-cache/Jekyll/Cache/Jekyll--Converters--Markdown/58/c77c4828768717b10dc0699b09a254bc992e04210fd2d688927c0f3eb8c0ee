I"28<ul id="markdown-toc">
  <li><a href="#时间复杂度和空间复杂度" id="markdown-toc-时间复杂度和空间复杂度">时间复杂度和空间复杂度</a></li>
  <li><a href="#冒泡排序蛮力法" id="markdown-toc-冒泡排序蛮力法">冒泡排序（蛮力法）</a></li>
  <li><a href="#选择排序蛮力法" id="markdown-toc-选择排序蛮力法">选择排序（蛮力法）</a></li>
  <li><a href="#插入排序减治法" id="markdown-toc-插入排序减治法">插入排序（减治法）</a></li>
  <li><a href="#希尔排序" id="markdown-toc-希尔排序">希尔排序</a></li>
</ul>

<p>本博客的全部算法文章为原创，如需转换请备注转发链接谢谢~~~</p>

<p>备注：代码是自己手撕的，没有实践，如果有错，自己纠正，因为思想就是那样的了，我就节省时间不一一实践了。</p>

<h3 id="时间复杂度和空间复杂度">时间复杂度和空间复杂度</h3>

<p>下图就是本篇文章说到的排序算法，之后可能会补充其它的排序算法吧~
<br /></p>

<p><img src="/static/img/sort.jpg" alt="avatar" width="90%" /></p>

<hr />

<h3 id="冒泡排序蛮力法">冒泡排序（蛮力法）</h3>

<p>冒泡排序（bubble sort）过程如下（升序）：</p>

<p><img src="/static/img/sorts/1.gif" alt="1" width="50%" /></p>

<p>这里就以简单的以升序为例，因为冒泡排序的思想都是一样的，所以我就不做过多的阐述。</p>

<p>思想：对无序区从前向后依次比较相邻记录，若反序则交换，从而使得值较小的记录向前移，值较大的记录向后移（都说冒泡了，就跟在水中的气泡一样，体积大的先浮上来）</p>

<p>代码如下：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="n">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h3 id="选择排序蛮力法">选择排序（蛮力法）</h3>

<p>选择排序（selection_sort）过程如下（升序）:</p>

<p><img src="/static/img/sorts/2.gif" alt="2" width="50%" /></p>

<p>思想：在无序区找出最小的记录，然后将它与无序区的第一个记录交换，使得有序去扩展一个记录，同时无序区减少一个记录。</p>

<p>代码如下：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">void</span> <span class="n">selection_sort</span><span class="p">(</span><span class="n">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="n">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="n">index</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h3 id="插入排序减治法">插入排序（减治法）</h3>

<p>插入排序（InsertSort）过程如下（升序）：</p>

<p><img src="/static/img/sorts/3.gif" alt="3" width="50%" /></p>

<p>思想：插入排序（insertion sort）属于减治法的减一技术，即每一趟排序后将问题规模减少1，其基本思想的是依次将待排序序列中的每一个记录插入到一个已经排好序列的序列中，直到全部记录都排好序。</p>

<p>代码如下：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">void</span> <span class="no">Insertion_Sort</span><span class="p">(</span><span class="n">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="n">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h3 id="希尔排序">希尔排序</h3>

<p>希尔排序（Shell’s Sort）是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非常稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。</p>

<p>希尔排序（Shell’s Sort）过程如下（升序）:</p>

<p><img src="/static/img/sorts/4.gif" alt="4" width="70%" /></p>

<p><img src="/static/img/sorts/5.gif" alt="5" width="70%" /></p>

<p>思想：</p>

<p>原文：The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements, it can move some out-of-place elements into position faster than a simple nearest neighbor exchange.</p>

<p>这里就长话短说吧，如果你有更好的思想，可以邮箱联系–&gt;希尔排序其实就将待排序列分成很多个组，但是分组呢不是随便分的，是按照差距(gap)分组，差距(gap)怎么计算呢，就是假如你有15个数，n=15，然后差距(gap)=n/2=7。</p>

<p>例如图中的</p>

<table>
  <tbody>
    <tr>
      <td>下标</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <td>数组</td>
      <td>4</td>
      <td>2</td>
      <td>6</td>
      <td>3</td>
      <td>8</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>6</td>
      <td>2</td>
      <td>9</td>
      <td>3</td>
      <td>6</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>组别</td>
      <td>下标内部进行比较</td>
    </tr>
    <tr>
      <td>第一组</td>
      <td>0 , 7</td>
    </tr>
    <tr>
      <td>第二组</td>
      <td>1 , 8</td>
    </tr>
    <tr>
      <td>第三组</td>
      <td>2 , 9</td>
    </tr>
    <tr>
      <td>第四组</td>
      <td>3 , 10</td>
    </tr>
    <tr>
      <td>第五组</td>
      <td>4 , 11</td>
    </tr>
    <tr>
      <td>第六组</td>
      <td>5 , 12</td>
    </tr>
    <tr>
      <td>第七组</td>
      <td>6 , 13</td>
    </tr>
    <tr>
      <td>第八组</td>
      <td>0 , 7 , 14</td>
    </tr>
  </tbody>
</table>

<p>然后就进行比较，例如：第一组，下标为0和7的值进行比较，4 &gt; 3，则交换，一直按顺序来做。做完一轮后，继续缩小增量，此时的gap=7/2=3</p>

<table>
  <tbody>
    <tr>
      <td>下标</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <td>数组</td>
      <td>3</td>
      <td>2</td>
      <td>6</td>
      <td>2</td>
      <td>8</td>
      <td>1</td>
      <td>2</td>
      <td>4</td>
      <td>4</td>
      <td>6</td>
      <td>3</td>
      <td>9</td>
      <td>3</td>
      <td>6</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>组别</td>
      <td>下标内部进行比较</td>
    </tr>
    <tr>
      <td>第一组</td>
      <td>0 , 3 , 6 , 9 , 12</td>
    </tr>
    <tr>
      <td>第二组</td>
      <td>1 , 4 , 7 , 10 , 13</td>
    </tr>
    <tr>
      <td>第三组</td>
      <td>2 , 5 , 8 , 11 , 14</td>
    </tr>
  </tbody>
</table>

<p>以此类推…</p>

<p>代码如下：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">void</span> <span class="no">Shell_Sort</span><span class="p">(</span><span class="n">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="n">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    
    
<span class="p">}</span></code></pre></figure>

:ET