I"<ul id="markdown-toc">
  <li><a href="#概念" id="markdown-toc-概念">概念</a></li>
  <li><a href="#prim算法点" id="markdown-toc-prim算法点">prim算法（点）</a></li>
  <li><a href="#kruskal克鲁斯卡尔算法边" id="markdown-toc-kruskal克鲁斯卡尔算法边">(kruskal)克鲁斯卡尔算法（边）</a></li>
</ul>

<h4 id="概念">概念</h4>

<p>在无向图中，<font size="4" color="#800080">连通而且不含有圈（环路）的图</font>称为树。所以下面的两种算法中的重要问题是判断圈，即每次的新加入一个点或者边的同时又要判断是否形成圈。</p>

<p>接来下将一下prim算法和kruskal算法，这两种算法都基于贪心法，因为最小生成树（Minimal Spanning Tree，MST）问题满足贪心法的 “最优性原理” ，即全局最优包含局部最优。</p>

<hr />

<h4 id="prim算法点">prim算法（点）</h4>

<p>思想：对点进行贪心操作。从任意一个点 u 开始，把距离它最近的点 v 加入到 T 中；下一步，把距离 {u , v}最近的点 w 加入到 T 中；继续这个过程，直到所有的点都在 T 中。</p>

<p>过程如下：</p>

<p><img src="/static/img/algorithm/5.jpg" alt="5" width="90%" /></p>

<hr />

<h4 id="kruskal克鲁斯卡尔算法边">(kruskal)克鲁斯卡尔算法（边）</h4>

<p>思想：对边进行贪心操作。从最短的边开始，把它加入到 T 中；在剩下的边中找最短的边，加入到 T 中；继续这个过程，直到所有边都在 T 中。</p>

<p>过程如下：</p>

<p><img src="/static/img/algorithm/6.jpg" alt="6" width="90%" /></p>

<p><strong>kruskal算法编程有以下两个关键技术</strong></p>

<blockquote>
  <p>① 对边进行排序。可以用STL的sort()函数，排序后，依次把最短的边加入到 T 中。</p>

  <p>② 判断圈，即处理连通性问题。这个问题用并查集简单而高效，并查集是kruskal算法的绝配。</p>
</blockquote>

<p>kruskal 代码如下：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">typedef</span> <span class="n">struct</span><span class="p">{</span>

<span class="p">}</span></code></pre></figure>

<p><br /></p>

<p>kruskal + 并查集 的代码如下(hdu 1233)：</p>

:ET